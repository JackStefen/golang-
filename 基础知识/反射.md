# 1.反射 reflect
在Golang的实现中，每个interface变量都有一个对应pair，pair中记录了实际变量的值和类型:(value, type)
反射主要与Golang的interface类型相关（它的type是concrete type），只有interface类型才有反射一说。


## reflect.Kind
```
// A Kind represents the specific kind of type that a Type represents.
// The zero Kind is not a valid kind.
type Kind uint

const (
	Invalid Kind = iota //无效的类型
	Bool
	Int
	Int8
	Int16
	Int32
	Int64
	Uint
	Uint8
	Uint16
	Uint32
	Uint64
	Uintptr  //指针的整数类型
	Float32
	Float64
	Complex64
	Complex128
	Array
	Chan
	Func
	Interface  //接口类型
	Map
	Ptr
	Slice
	String
	Struct
	UnsafePointer
)
```
reflect 包提供了两个基础反射方法，分别是 TypeOf() 和 ValueOf() 方法，分别用于获取变量的类型和值，定义如下
```
// TypeOf returns the reflection Type that represents the dynamic type of i.
// If i is a nil interface value, TypeOf returns nil.
func TypeOf(i interface{}) Type {
	eface := *(*emptyInterface)(unsafe.Pointer(&i))
	return toType(eface.typ)
}


// ValueOf returns a new Value initialized to the concrete value
// stored in the interface i. ValueOf(nil) returns the zero Value.
func ValueOf(i interface{}) Value {
	if i == nil {
		return Value{}
	}

	// TODO: Maybe allow contents of a Value to live on the stack.
	// For now we make the contents always escape to the heap. It
	// makes life easier in a few places (see chanrecv/mapassign
	// comment below).
	escapes(i)

	return unpackEface(i)
}
```
## reflect.Type
是一个接口类型，详情如下
```
// Type is the representation of a Go type.
//
// Not all methods apply to all kinds of types. Restrictions,
// if any, are noted in the documentation for each method.
// Use the Kind method to find out the kind of type before
// calling kind-specific methods. Calling a method
// inappropriate to the kind of type causes a run-time panic.
//
// Type values are comparable, such as with the == operator,
// so they can be used as map keys.
// Two Type values are equal if they represent identical types.
type Type interface {
	// Methods applicable to all types.

	// Align returns the alignment in bytes of a value of
	// this type when allocated in memory.
	Align() int

	// FieldAlign returns the alignment in bytes of a value of
	// this type when used as a field in a struct.
	FieldAlign() int

	// Method returns the i'th method in the type's method set.
	// It panics if i is not in the range [0, NumMethod()).
	//
	// For a non-interface type T or *T, the returned Method's Type and Func
	// fields describe a function whose first argument is the receiver.
	//
	// For an interface type, the returned Method's Type field gives the
	// method signature, without a receiver, and the Func field is nil.
	Method(int) Method

	// MethodByName returns the method with that name in the type's
	// method set and a boolean indicating if the method was found.
	//
	// For a non-interface type T or *T, the returned Method's Type and Func
	// fields describe a function whose first argument is the receiver.
	//
	// For an interface type, the returned Method's Type field gives the
	// method signature, without a receiver, and the Func field is nil.
	MethodByName(string) (Method, bool)

	// NumMethod returns the number of exported methods in the type's method set.
	NumMethod() int

	// Name returns the type's name within its package for a defined type.
	// For other (non-defined) types it returns the empty string.
	Name() string

	// PkgPath returns a defined type's package path, that is, the import path
	// that uniquely identifies the package, such as "encoding/base64".
	// If the type was predeclared (string, error) or not defined (*T, struct{},
	// []int, or A where A is an alias for a non-defined type), the package path
	// will be the empty string.
	PkgPath() string

	// Size returns the number of bytes needed to store
	// a value of the given type; it is analogous to unsafe.Sizeof.
	Size() uintptr

	// String returns a string representation of the type.
	// The string representation may use shortened package names
	// (e.g., base64 instead of "encoding/base64") and is not
	// guaranteed to be unique among types. To test for type identity,
	// compare the Types directly.
	String() string

	// Kind returns the specific kind of this type.
	Kind() Kind

	// Implements reports whether the type implements the interface type u.
	Implements(u Type) bool

	// AssignableTo reports whether a value of the type is assignable to type u.
	AssignableTo(u Type) bool

	// ConvertibleTo reports whether a value of the type is convertible to type u.
	ConvertibleTo(u Type) bool

	// Comparable reports whether values of this type are comparable.
	Comparable() bool

	// Methods applicable only to some types, depending on Kind.
	// The methods allowed for each kind are:
	//
	//	Int*, Uint*, Float*, Complex*: Bits
	//	Array: Elem, Len
	//	Chan: ChanDir, Elem
	//	Func: In, NumIn, Out, NumOut, IsVariadic.
	//	Map: Key, Elem
	//	Ptr: Elem
	//	Slice: Elem
	//	Struct: Field, FieldByIndex, FieldByName, FieldByNameFunc, NumField

	// Bits returns the size of the type in bits.
	// It panics if the type's Kind is not one of the
	// sized or unsized Int, Uint, Float, or Complex kinds.
	Bits() int

	// ChanDir returns a channel type's direction.
	// It panics if the type's Kind is not Chan.
	ChanDir() ChanDir

	// IsVariadic reports whether a function type's final input parameter
	// is a "..." parameter. If so, t.In(t.NumIn() - 1) returns the parameter's
	// implicit actual type []T.
	//
	// For concreteness, if t represents func(x int, y ... float64), then
	//
	//	t.NumIn() == 2
	//	t.In(0) is the reflect.Type for "int"
	//	t.In(1) is the reflect.Type for "[]float64"
	//	t.IsVariadic() == true
	//
	// IsVariadic panics if the type's Kind is not Func.
	IsVariadic() bool

	// Elem returns a type's element type.
	// It panics if the type's Kind is not Array, Chan, Map, Ptr, or Slice.
	Elem() Type

	// Field returns a struct type's i'th field.
	// It panics if the type's Kind is not Struct.
	// It panics if i is not in the range [0, NumField()).
	Field(i int) StructField

	// FieldByIndex returns the nested field corresponding
	// to the index sequence. It is equivalent to calling Field
	// successively for each index i.
	// It panics if the type's Kind is not Struct.
	FieldByIndex(index []int) StructField

	// FieldByName returns the struct field with the given name
	// and a boolean indicating if the field was found.
	FieldByName(name string) (StructField, bool)

	// FieldByNameFunc returns the struct field with a name
	// that satisfies the match function and a boolean indicating if
	// the field was found.
	//
	// FieldByNameFunc considers the fields in the struct itself
	// and then the fields in any embedded structs, in breadth first order,
	// stopping at the shallowest nesting depth containing one or more
	// fields satisfying the match function. If multiple fields at that depth
	// satisfy the match function, they cancel each other
	// and FieldByNameFunc returns no match.
	// This behavior mirrors Go's handling of name lookup in
	// structs containing embedded fields.
	FieldByNameFunc(match func(string) bool) (StructField, bool)

	// In returns the type of a function type's i'th input parameter.
	// It panics if the type's Kind is not Func.
	// It panics if i is not in the range [0, NumIn()).
	In(i int) Type

	// Key returns a map type's key type.
	// It panics if the type's Kind is not Map.
	Key() Type

	// Len returns an array type's length.
	// It panics if the type's Kind is not Array.
	Len() int

	// NumField returns a struct type's field count.
	// It panics if the type's Kind is not Struct.
	NumField() int

	// NumIn returns a function type's input parameter count.
	// It panics if the type's Kind is not Func.
	NumIn() int

	// NumOut returns a function type's output parameter count.
	// It panics if the type's Kind is not Func.
	NumOut() int

	// Out returns the type of a function type's i'th output parameter.
	// It panics if the type's Kind is not Func.
	// It panics if i is not in the range [0, NumOut()).
	Out(i int) Type

	common() *rtype
	uncommon() *uncommonType
}
```
## reflect.Value
是一个结构体，详情如下
```
// Value is the reflection interface to a Go value.
//
// Not all methods apply to all kinds of values. Restrictions,
// if any, are noted in the documentation for each method.
// Use the Kind method to find out the kind of value before
// calling kind-specific methods. Calling a method
// inappropriate to the kind of type causes a run time panic.
//
// The zero Value represents no value.
// Its IsValid method returns false, its Kind method returns Invalid,
// its String method returns "<invalid Value>", and all other methods panic.
// Most functions and methods never return an invalid value.
// If one does, its documentation states the conditions explicitly.
//
// A Value can be used concurrently by multiple goroutines provided that
// the underlying Go value can be used concurrently for the equivalent
// direct operations.
//
// To compare two Values, compare the results of the Interface method.
// Using == on two Values does not compare the underlying values
// they represent.
type Value struct {
	// typ holds the type of the value represented by a Value.
	typ *rtype

	// Pointer-valued data or, if flagIndir is set, pointer to data.
	// Valid when either flagIndir is set or typ.pointers() is true.
	ptr unsafe.Pointer

	// flag holds metadata about the value.
	// The lowest bits are flag bits:
	//	- flagStickyRO: obtained via unexported not embedded field, so read-only
	//	- flagEmbedRO: obtained via unexported embedded field, so read-only
	//	- flagIndir: val holds a pointer to the data
	//	- flagAddr: v.CanAddr is true (implies flagIndir)
	//	- flagMethod: v is a method value.
	// The next five bits give the Kind of the value.
	// This repeats typ.Kind() except for method values.
	// The remaining 23+ bits give a method number for method values.
	// If flag.kind() != Func, code can assume that flagMethod is unset.
	// If ifaceIndir(typ), code can assume that flagIndir is set.
	flag

	// A method value represents a curried method invocation
	// like r.Read for some receiver r. The typ+val+flag bits describe
	// the receiver r, but the flag's Kind bits say Func (methods are
	// functions), and the top bits of the flag give the method number
	// in r's type's method table.
}
```


```
package main

import (
    "fmt"
    "reflect"
    "strconv"
)

type Student struct {
    Name string
    Gender int
}

func (st Student) String() string {
    rlst := st.Name + strconv.Itoa(st.Gender)
    return rlst
}

func main() {
    // 1.查看TypeOf和ValueOf的返回值.及其返回值类型
    var a int = 12
    fmt.Printf("reflect ValueOf: %v\n", reflect.ValueOf(a))
    fmt.Printf("reflect TypeOf: %v\n", reflect.TypeOf(a))
    fmt.Printf("TypeOf return type: %v-----ValueOf return type: %v\n", reflect.TypeOf(reflect.TypeOf(a)), reflect.TypeOf(reflect.ValueOf(a)))
    // 2.reflect.Value().Interface() 还原原始变量
    c := reflect.ValueOf(a).Interface()
    fmt.Printf("original value: %v\n", c.(int))
    // 3.Value Type() method is equal to TypeOf() method
    fmt.Printf("Type method of value struct vs TypeOf of type: %v\n", reflect.TypeOf(a) == reflect.ValueOf(a).Type())
    // 4.struct typeof and valueof
    st := Student{Name:"zhao",Gender: 1}
    fmt.Println("valueOf: ", reflect.ValueOf(st))
    fmt.Println("typeOf: ", reflect.TypeOf(st))
}
// ==========================
reflect ValueOf: 12
reflect TypeOf: int
TypeOf return type: *reflect.rtype-----ValueOf return type: reflect.Value
original value: 12
Type method of value struct vs TypeOf of type: true
valueOf:  zhao1
typeOf:  main.Student
```

- 反射通过`reflect.ValueOf()`用来获取输入参数接口中的数据的值，如果接口为空则返回0，
- `reflect.TypeOf()`用来动态获取输入参数接口中的值的类型，如果接口为空则返回nil.

调用`reflect.ValueOf(X)`之后得到的是一个reflect.Value类型的数据，调用它的`Interface()`方法会得到接口变量的真实内容，然后可以通过类型判断进行转换，转换为原有真实类型。只有当X是指针的时候，才可以通过reflec.Value修改实际变量X的值，即：要修改反射类型的对象就一定要保证其值是“addressable”的。
```
var aint = 21
avo := reflect.ValueOf(&aint).Elem()
fmt.Println(avo.Type())
fmt.Println(avo.CanSet())
// =================
int
true
```
重新设置值：
```
   avo.SetInt(12)
   fmt.Println(avo)
   // ===========
   12
```
反射调用方法
```
    mv  := vl.MethodByName("String")
    args := make([]reflect.Value, 0)
    fmt.Println("reflect Call:", mv.Call(args))
    //=============
    reflect Call: [zhao1]
```

# 2.反射中的类型和方法遍历
```
package main

import (
    "fmt"
    "reflect"
)

type User struct {
    id   int
    name string
    age  int
}

func (u User) Descrite() {
    fmt.Println("descrite method: ", u.name)
}

func main() {
    var user = User{
        name: "myname",
        age:  13,
        id:   10,
    }
    var uid int = 12
    Info(user)
    Info(uid)
}

func Info(o interface{}) {
    t := reflect.TypeOf(o)
    fmt.Println("Info name: ", t.Name())
    fmt.Println("Info Kind: ", t.Kind())
    if k := t.Kind(); k != reflect.Struct {
        fmt.Println("argument type is err")
        return
    }
    v := reflect.ValueOf(o)
    fmt.Println("Info valueOf: ", v)
    fmt.Println("Fields: ")
    for i := 0; i < t.NumField(); i++ {
        f := t.Field(i)
        val := v.Field(i)
        fmt.Printf("%6s: %v = %v\n", f.Name, f.Type, val)
    }
    for i := 0; i < t.NumMethod(); i++ {
        m := t.Method(i)
        fmt.Printf("%s - %v\n", m.Name, m.Type)
    }
}
//========================
Info name:  User
Info Kind:  struct
Info valueOf:  {10 myname 13}
Fields:
    id: int = 10
  name: string = myname
   age: int = 13
Descrite - func(main.User)
Info name:  int
Info Kind:  int
argument type is err
```

# 3.反射中，匿名结构体的获取
```
package main

import (
    "fmt"
    "reflect"
)

type User struct {
    id   int
    name string
    age  int
}

type Manager struct {
    User
    salary float64
}

func (u User) Descrite() {
    fmt.Println("descrite method: ", u.name)
}

func main() {

    var user = User{
        name: "myname",
        age:  13,
        id:   10,
    }
    var mg = Manager{User: user, salary: 100000.00}
    t := reflect.TypeOf(mg)
    fmt.Println("Type Name method: ", t.Name())
    fmt.Printf("%#v\n", t.FieldByIndex([]int{0, 1}))
}
// ====================
Type Name method:  Manager
reflect.StructField{Name:"name", PkgPath:"main", Type:(*reflect.rtype)(0x10a5d40), Tag:"", Offset:0x8, Index:[]int{1}, Anonymous:false}
```
# 4.通过反射动态的调用方法
```
package main

import (
    "fmt"
    "reflect"
)

type User struct {
    Id int
    Name string
    Age int
}

func (u User) Hello(name string) {
    fmt.Println("Hello ", name, ", my name is ", u.Name)
}

func main() {
    u := User{1, "yangmi", 12}
    v := reflect.ValueOf(u)
    mv := v.MethodByName("Hello")
    args := []reflect.Value{reflect.ValueOf("joe")}
    mv.Call(args)
}
// ================
Hello  joe , my name is  yangmi
```
# 方法介绍：
`func Indirect(v Value) Value` 该方法返回参数value 指向的值。如果v为一个空指针，该方法返回一个零值，如果v不是一个指针，则直接返回v。 
`net/rpc`中的Server的注册方法中有使用过该方法，如下：
```
func (server *Server) register(rcvr interface{}, name string, useName bool) error {
	s := new(service)
	s.typ = reflect.TypeOf(rcvr)
	s.rcvr = reflect.ValueOf(rcvr)
	sname := reflect.Indirect(s.rcvr).Type().Name()
	if useName {
		sname = name
	}
	if sname == "" {
		s := "rpc.Register: no service name for type " + s.typ.String()
		log.Print(s)
		return errors.New(s)
	}
	if !isExported(sname) && !useName {
		s := "rpc.Register: type " + sname + " is not exported"
		log.Print(s)
		return errors.New(s)
	}
	s.name = sname

	// Install the methods
	s.method = suitableMethods(s.typ, true)

	if len(s.method) == 0 {
		str := ""

		// To help the user, see if a pointer receiver would work.
		method := suitableMethods(reflect.PtrTo(s.typ), false)
		if len(method) != 0 {
			str = "rpc.Register: type " + sname + " has no exported methods of suitable type (hint: pass a pointer to value of that type)"
		} else {
			str = "rpc.Register: type " + sname + " has no exported methods of suitable type"
		}
		log.Print(str)
		return errors.New(str)
	}

	if _, dup := server.serviceMap.LoadOrStore(sname, s); dup {
		return errors.New("rpc: service already defined: " + sname)
	}
	return nil
}
```

`func (v Value) Type() Type`该方法返回v的类型Type